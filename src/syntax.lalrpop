use std::str::FromStr;
use crate::ast::*;

grammar;

pub Expr0: Expr0 = {
    <l: Expr0> "==" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::Equal},
    <l: Expr0> "!=" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::NotEq},
    <l: Expr0> ">=" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::EqGreaterThan},
    <l: Expr0> "<=" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::EqLessThan},
    <l: Expr0> ">" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::GreaterThan},
    <l: Expr0> "<" <r: Expr1> => Expr0::Expr0 {left: Box::new(l), right: r, op_code: OpCode0::LessThan},
    Expr1 => Expr0::Expr1(<>),
};

Expr1: Expr1 = {
    <l: Expr1> "+" <r:Expr2> => Expr1::Expr1 {left: Box::new(l), right: r, op_code: OpCode1::Add},
    <l: Expr1> "-" <r:Expr2> => Expr1::Expr1 {left: Box::new(l), right: r, op_code: OpCode1::Sub},
    Expr2 => Expr1::Expr2(<>),
}

Expr2: Expr2 = {
    <l: Expr2> r"\*" <r:Expr3> => Expr2::Expr2 {left: Box::new(l), right: r, op_code: OpCode2::Multi},
    <l: Expr2> "/" <r:Expr3> => Expr2::Expr2 {left: Box::new(l), right: r, op_code: OpCode2::Div},
    <l: Expr2> "%" <r:Expr3> => Expr2::Expr2 {left: Box::new(l), right: r, op_code: OpCode2::Mod},
    Expr3 => Expr2::Expr3(<>),
}

Expr3: Expr3 = {
    <l: Expr3> "d" <r: Term> => Expr3::Expr3 {left: Box::new(l), right: r, op_code: OpCode3::Dice},
    Term => Expr3::Term(<>),
}

Term: Term = {
    Literal => Term::Literal(<>),
    "[" <CommaList<Expr0>> "]" => Term::List(<>),
    "(" <Expr0> ")" => Term::Expr0(Box::new(<>)),
};

CommaList<T>: Vec<T> = {
    <xs: (<T> ",")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            let mut xs = xs;
            xs.push(x);
            xs
        }
    }
}

Literal: Literal = {
    Num => Literal::Num(<>)
}

Num: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap(),
};
