use std::str::FromStr;
use crate::ast::*;
use std::rc::Rc;

grammar;

pub Expr: Expr = {
    <i: Ident> ":=" <f: FncDef> => Expr::Assign(Rc::new(i), f),
    FncDef => Expr::FncDef(<>)
}

FncDef: FncDef = {
    "\\" <a: Ident> "->" <i: FncDef> => FncDef::FncDef(Rc::new(a), Rc::new(i)),
    Expr0 => FncDef::Expr0(<>),
}

Expr0: Expr0 = {
    <l: Expr0> "@" <r: Expr1> => Expr0::Expr0(Box::new(l), r, OpCode0::At),
    Expr1 => Expr0::Expr1(<>),
}

Expr1: Expr1 = {
    <l: Expr1> "==" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::Equal),
    <l: Expr1> "!=" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::NotEq),
    <l: Expr1> ">=" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::EqGreaterThan),
    <l: Expr1> "<=" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::EqLessThan),
    <l: Expr1> ">" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::GreaterThan),
    <l: Expr1> "<" <r: Expr2> => Expr1::Expr1(Box::new(l), r, OpCode1::LessThan),
    Expr2 => Expr1::Expr2(<>),
};

Expr2: Expr2 = {
    <l: Expr2> "+" <r:Expr3> => Expr2::Expr2(Box::new(l), r, OpCode2::Add),
    <l: Expr2> "-" <r:Expr3> => Expr2::Expr2(Box::new(l), r, OpCode2::Sub),
    Expr3 => Expr2::Expr3(<>),
}

Expr3: Expr3 = {
    <l: Expr3> "*" <r:Expr4> => Expr3::Expr3(Box::new(l), r, OpCode3::Multi),
    <l: Expr3> "/" <r:Expr4> => Expr3::Expr3(Box::new(l), r, OpCode3::Div),
    <l: Expr3> "%" <r:Expr4> => Expr3::Expr3(Box::new(l), r, OpCode3::Mod),
    Expr4 => Expr3::Expr4(<>),
}

Expr4: Expr4 = {
    <l: Expr4> "d" <r: Term> => Expr4::Expr4(Box::new(l), r, OpCode4::Dice),
    <l: Expr4> "D" <r: Term> => Expr4::Expr4(Box::new(l), r, OpCode4::Dice),
    Term => Expr4::Term(<>),
}

Term: Term = {
    Literal => Term::Literal(<>),
    "[" <CommaList<Expr>> "]" => Term::List(<>),
    "(" <SemicolonList<Expr>> ")" => Term::Expr(<>),
};

CommaList<T>: Vec<T> = {
    <xs: (<T> ",")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            let mut xs = xs;
            xs.push(x);
            xs
        }
    }
}

SemicolonList<T>: Vec<T> = {
    <xs: (<T> ";")*> <x: T> => {
        let mut xs = xs;
        xs.push(x);
        xs
    }
}

Literal: Literal = {
    Num => Literal::Num(<>),
    Ident => Literal::Ident(Rc::new(<>)),
}

Num: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap(),
};

Ident: String = {
    r"[A-z]+" => String::from(<>),
}
